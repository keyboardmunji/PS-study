// Authored by : keyboardmunji
// Created on 2025-05-23.
#include <bits/stdc++.h>
using namespace std;

int t;

int main(void) {
    ios :: sync_with_stdio(false);
    cin.tie(NULL);

    cin >> t;
    while (t--) {
        int n,k;
        long long sum = 0;
        cin >> n >> k;
        // 사이클마다 측정 i는 사이클 개수.
        for (int i = 1; i<=k;i++) {
            if (k != 1 && i == 1)
                continue;
            // i-1 처리.
            long long s1 = 1;
            if (i != 1)
                s1 *= i - 1;
            // k-2Pi-2
            long long s2 = 1;
            if (i > 2) {
                for (int j = 1;j <= i - 2 ;j++) {
                    s2 *= k - 1 - j;
                }
            }
            // s2 -> (n-1)! 계산.
            long long s3 = 1;
            for (int j = 1; j <= n - i;j++)
                s3 *= j;
            sum += s1 * s2 * s3;
        }
        cout << sum <<'\n';
    }

    return 0;
}
/*
1. t <= 1000 따라서, 최대 10만의 연산을 해야함.
2. 흠,, 20 7의 값을 보면 1158어쩌구 저쩌구인데, 답이 없는 듯.
    각 수들이 동일한 위상을 가지고 있지도 않음.why ? 대소 관계가 있으니까.
3. 그럼 감이 안잡히니 예시를 보자.
    1. 4 1 의 값은 6임.
    1이 최대가 되려면 무조건 1번만에 최대가 되야함. -> 따라서 2 3 4의 위치가 바뀔 수 있는 값인 6임.
    2. 7 3의 값은 168임.
    또한 알아야할 점은 P(1)의 값은 최대 3이여야함. 당근 빠따지. 그래서 앞에 3개의 조합의 개수 * 뒤에 순열의 개수임.
    그러면 4!은 24이고, 결과가 168이므로 앞에 3개의 조합이 7이라는 것을 알 수 있음.
    왜 7일까?
    3!은 6인데..? 아하!, 사이클이 1 3 1 3인경우 2에는 뭐든지 와도 됨. ㄷ
    그러면 그냥 사이클이 1일때, 2일때, 3일때를 나누고, 생각해야할듯.
    사이클이 1인건 안됨. -> 이건 왜일까? 왜냐면 처음 O(1)을 들어가는 것 자체가 1을 포함해야한다는것을 내포함.
    2일 때 -> 1 3 1 3 1 밖에 없음. -> 왜냐면 1을 포함해야하고 3도 포함해야하므로, -> 따라서 5! => 120
    3일 때 -> 1 2 3, 1 3 2, 2개임. -> 따라서 4! * 2라, 48 정확히 나옴.
4. 결론 -> 제일 처음에 나올 숫자는 1이다.
5. 그래서 사이클이 2일때부터 사이클이 n일때까지 확인하면 된다.
6. 그래서 사이클이 i일때, n,k에대해서 식을 내려보면
    1. (i - 1) * (k-2Pi-2) * (n-i)!
    2. 예외 처리가 많긴한데, i <= 2, k <= 2 일때 따로 처리해야함. ㅠ
    3. i는 k와 관련있으므로 k <= 2일때만 따로 처리하면 될듯.
*/